[{"title":"小张开车视频","url":"/2025/05/30/小张开车视频/","content":"\n## 小张开车视频\n\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 56.25%;\">\n  <video width=\"100%\" height=\"100%\" controls style=\"position: absolute; top: 0; left: 0;\">\n    <source src=\"https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3YvYy81YjQ2ZmEzMThhOTY2YjUxL0VhNngwN3RobHdSQWpMR1J6aW9icTZnQmhCQmVrSGhMZEQyOFVEazBEY1UxTmc_ZT1hekw3c1g.mp4\" type=\"video/mp4\">\n    您的浏览器不支持视频标签。\n  </video>\n</div>\n"},{"title":"减肥诀窍","url":"/2025/05/27/减肥诀窍/","content":"\n# 减肥诀窍\n- 细嚼慢咽，尽量多咀嚼且延长用餐时间。\n  >  原因：你吃得太快大脑反应不过来你饱了，等你感觉饱的时候其实已经超量了\n- 每天如果不是饿的发慌，一天2顿饭够了，\n或者把2顿分成4份来吃。这样应该更能减肥。\n- 先吃素菜，然后减少饭量\n\n---\n\n**参考链接：**\n- [相关讨论](https://linux.do/t/topic/681849)\n","tags":["减肥"]},{"title":"小张的像素风照片","url":"/2025/05/25/小张的像素风照片/","content":"# 小张的像素风照片\n\n![1](image1.png)\n![2](image2.jpg)\n![3](image3.png)\n","tags":["小张"]},{"title":"2025-5-24","url":"/2025/05/24/2025-5-24/","content":"# 又是好吃的一天\n\n今天小张发给我很多好吃的，我很开心。  \n什么时候才能再次吃到小张做的美食呢？\n**很好奇知了猴的味道。**\n![包饺子](https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy81YjQ2ZmEzMThhOTY2YjUxL0VjSWlwQ2R5djVwSXZia3E4QVhESGNNQkk0bUUzTmtzdjdveG90X2tIMUcwOEE_ZT0xenZZMmY.jpg)\n![知了猴](https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy81YjQ2ZmEzMThhOTY2YjUxL0Vkazhrc1Q5WktSQ2czUkdVQzBya0hFQkd5WG5fUzJHRFB4TXdqUXI5bTFsdVE_ZT15T2xxN1Q.jpg)\n![馒头蛋糕](https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy81YjQ2ZmEzMThhOTY2YjUxL0VaS09wVUROcnZ0QXRac3J6UmM1SHV3QklTUEhzTkZQd1ZJRFhGcVBvaDA5UkE_ZT1UbFI1TkM.jpg)\n![馒头蛋糕](https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy81YjQ2ZmEzMThhOTY2YjUxL0VaZ0JKNHUwU3Z0RnFzZFhYTW53R3VZQmxiV3I1WEFWeGtxTndqR3hmS1lueEE_ZT1YRHlLM1Q.jpg)\n![想尝尝是什么味道](https://dlink.host/1drv/aHR0cHM6Ly8xZHJ2Lm1zL2kvYy81YjQ2ZmEzMThhOTY2YjUxL0VWMTdwZFpfMUdaQmwwRmRGRU5SaERFQkdPclF5MzBYY3RUOTV5eld5VkNkM2c_ZT1yemg1Zlc.jpg)"},{"title":"test","url":"/2025/05/23/test/","content":"# test\n"},{"title":"测试","url":"/2025/05/23/测试5-23/","content":"测试5-23\n\n![](https://s2.loli.net/2025/05/23/8NSMQq2u9b1LGIB.jpg)😍 \n\n\n| col1 | col2 | col3 |\n| ---- | ---- | ---- |\n|      |      |      |\n|      |      |      |\n"},{"title":"测试使用qexo进行发布","url":"/2025/03/16/测试/","content":"# 测试是否发布成功\n\n111222333\n","tags":["测试"],"categories":["测试"]},{"title":"33. 搜索旋转排序数组","url":"/2025/01/21/33-搜索旋转排序数组/","content":"# 33. 搜索旋转排序数组\n\n\\[4,5,6,&#x37;*,&#x20;*&#x20;    0,1,2]\n\n将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。 此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.\n\n![](image1.png)\n\n## 判断条件可以由该图得出\n\n```java\npackage leetcode.editor.cn.mycode.ID33;\n\nimport java.util.Arrays;\n\npublic class 搜索旋转排序数组 {\n    class Solution {\n        public int search(int[] nums, int target) {\n            int n = nums.length;\n            int l=0,r=n-1;\n            while (l<=r)\n            {     \n                int mid=(l+r)/2;\n                if(nums[mid]==target){\n                    return mid;\n                }\n                //如果左边为有序\n                if(nums[l]<=nums[mid])\n                {\n                    //利用左边有序判断是否在左边\n                    if(nums[l]<=target&&nums[mid]>target)\n                    {\n                       r=mid-1;\n                    }\n                    else  l=mid+1;\n                }\n                else //右边有序\n                {\n                    //利用左边有序判断是否在左边\n                    if (nums[mid] < target && nums[r] >= target) {\n                        l = mid + 1;\n                    } else r = mid - 1;\n                }\n            }\n            return -1;\n        }\n\n    }\n\n}\n\n```\n"},{"title":"java动态代理的学习","url":"/2025/01/19/java动态代理的学习/","content":"# java动态代理的学习\n\n![代理的自我认识](1.svg)\n\n![接口与实现的关系](image1.png)\n\n**代理想知道原来的对象可以实现什么功能，可以通过接口。原来的对象提供出自己的接口就可以了。**\n\n![代码执行流程](image2.png)\n\n动态代理可以将与业务无关的内容统一交给代理去实现\n","tags":["java"],"categories":["java基础"]},{"title":"友链新增","url":"/2025/01/19/友链新增/","content":"\n# 完善友链\n使用[图床](https://sm.ms/)上传好友的logo 并且配置\n","tags":["友链"],"categories":["备用"]},{"title":"完成-Hexo-Butterfly主题在主页添加GitHub贡献日历","url":"/2025/01/19/完成-Hexo-Butterfly主题在主页添加GitHub贡献日历/","content":"重要配置  \n user: pengcai6 #git用户名  \n  apiurl: '<https://github-contribute-plum.vercel.app>'   #该网站使用vercel搭建\n  minheight:  \n  \n## 目前只在我的关于中展示\n\n![具体可以前往关于观看](image1.png)\n"},{"title":"146. LRU 缓存","url":"/2025/01/18/146-LRU-缓存/","content":"# 146. LRU 缓存\n\n[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)\n\n## 解法1\n\n```java\npackage leetcode.editor.cn.mycode.ID146;\n\nimport java.util.HashMap;\n\n\n/**\n * 手写双向链表加哈希表\n */\npublic class LRUCache1 {\n        class node{\n            public int val,key;\n            public node prev,next;\n\n            public node(int key, int val) {\n                this.key = key;\n                this.val = val;\n            }\n        }\n        class doubleList{\n            public node tail;\n            public node head;\n            private int size;\n\n            public doubleList() {\n                this.size=0;\n                head=new node(0,0);\n                tail=new node(0,0);\n                head.next=tail;\n                tail.prev=head;\n            }\n\n            /**\n             * 在尾部插入\n             * @param x\n             */\n            public void addList(node x)\n            {\n                x.prev=tail.prev;\n                x.next=tail;\n                tail.prev.next=x;\n                tail.prev=x;\n                size++;\n            }\n\n            /**\n             * 一定存在\n             *\n             * @param x\n             */\n            public void remove(node x){\n            x.prev.next=x.next;\n            x.next.prev=x.prev;\n            size--;\n            }\n\n            public node removeFirst(){\n                if(head.next==tail)\n                {\n                    return null;\n                }\n                node first = head.next;\n                remove(first);\n                return first;\n            }\n\n            public int size()\n            {\n                return size;\n            }\n\n        }\n\n\n\n    HashMap<Integer,node> map;\n    doubleList cache;\n\n    int cap;\n    public LRUCache1(int capacity) {\n        this.cap=capacity;\n        this.map =new HashMap<>();\n        this.cache=new doubleList();\n    }\n\n    private void makeRecently(int key)\n    {\n        node node = map.get(key);\n        cache.remove(node);\n        cache.addList(node);\n    }\n    private void addRecently(int key ,int value)\n    {\n        node node = new node(key, value);\n        cache.addList(node);\n        map.put(key,node);\n    }\n    private void deleteKey(int key)\n    {\n        node node = map.get(key);\n        cache.remove(node);\n        map.remove(key);\n    }\n\n    private void removeLeastRecently(){\n        node node = cache.removeFirst();\n        map.remove(node.key);\n    }\n\n\n    public int get(int key) {\n        if(!map.containsKey(key))\n        {\n\n            return -1;\n        }\n        makeRecently(key);\n        return map.get(key).val;\n\n    }\n\n    public void put(int key, int value) {\n        if(map.containsKey(key))\n        {\n            deleteKey(key);\n            addRecently(key,value);\n            return ;\n        }\n        if(cap==cache.size){\n            removeLeastRecently();\n        }\n        addRecently(key,value);\n    }\n\n\n}\n\n```\n\n## 解法2\n\n```java\npackage leetcode.editor.cn.mycode.ID146;\n\nimport java.util.LinkedHashMap;\n\n/**\n * 使用java中自带的linkedHashMap\n */\npublic class LRUCache2 {\n        int cap;\n        LinkedHashMap<Integer,Integer> cache=new LinkedHashMap<>();\n\n\n    public LRUCache2(int capacity) {\n            this.cap=capacity;\n    }\n\n    public void makeRecently(int key)\n    {\n        Integer value = cache.get(key);\n        //删除重新插入到队尾\n        cache.remove(key);\n        cache.put(key,value);\n    }\n\n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1;\n        }\n        Integer value = cache.get(key);\n        makeRecently(key);\n    return value;\n    }\n\n    public void put(int key, int value) {\n        if(cache.containsKey(key))\n        {\n            cache.put(key,value);\n            makeRecently(key);\n            return;\n        }\n        if(cache.size()>=cap)\n        {\n            //链表头部就是最久未使用的key\n            Integer oldKey = cache.keySet().iterator().next();\n            cache.remove(oldKey);\n        }\n        cache.put(key, value);\n    }\n}\n\n```\n","tags":["算法","LRU"],"categories":["java","算法"]},{"title":"11盛最多水的容器","url":"/2025/01/16/11盛最多水的容器/","content":"# 11盛最多水的容器\n\n```java\n\n public static int maxArea(int[] height) {\n        int res = 0;\n        for (int l = 0, r = height.length-1;l<r; ) {\n            //移动右边的面积比移动左边的面积大，那么就移动右边的否则移动左边\n            //计算面积\n            int are = Math.min(height[l], height[r]) * (r - l);\n            res = Math.max(are, res);\n            if (height[l] < height[r]) {\n               l++;\n\n            } else {\n                r--;\n            }\n        }\n        return res;\n}\n\n\n```\n","tags":["算法"],"categories":["算法 双指针"]},{"title":"15三数之和","url":"/2025/01/16/15三数之和/","content":"```java\n\n\npublic class ID15三数之和 {\n    public static List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n//        for (int i = 0; i < nums.length; i++) {\n//            for (int j = i+1; j < nums.length; j++) {\n//                for (int k = j+1; k < nums.length; k++) {\n//                    if(nums[i] + nums[j] + nums[k] == 0){\n//                        res.add(Arrays.asList(nums[i] , nums[j] , nums[k]));\n//                    }\n//                }\n//\n//            }\n//        }\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length-2; i++) {\n            if(i>0&&nums[i]==nums[i-1])continue;\n            int l=i+1;\n            int r=nums.length-1;\n            while (l<r)\n            {\n                int sum = nums[i] + nums[l] + nums[r];\n                if(sum==0) {\n                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));\n                    // 去重l和r\n                    while (l < r && nums[l] == nums[l + 1]) l++;\n                    while (l < r && nums[r] == nums[r - 1]) r--;\n                    l++;\n                    r--;\n                }\n                else if (sum<0) l++;\n                else r--;\n\n\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        List<List<Integer>> lists = threeSum(new int[]{0, 0, 0,0\n        });\n        System.out.println(\"lists = \" + lists);\n    }\n}\n\n\n\n```"},{"title":"438找到字符串中所有字母异位词","url":"/2025/01/16/438/","content":"# 方法一：定长滑窗\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n          //保存答案\n        List<Integer> res = new ArrayList<>();\n\n        //p的异位词\n        //给定两个字符串 s 和 p，找到 s 中所有 p 的\n        //异位词\n        // 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n        int[] cntS = new int[30];\n        int[] cntP = new int[30];\n        //取出子串\n        for (char c : p.toCharArray()) {\n              cntP[c-'a']++;\n        }\n        for(int r=0;r<s.length();r++)\n        {\n            cntS[s.charAt(r)-'a']++;\n            int l = r - p.length() + 1;\n            if(l<0){\n                continue;\n            }\n            if(Arrays.equals(cntS,cntP)){\n                res.add(l);\n            }\n            cntS[s.charAt(l) - 'a']--;\n        }\n\n        return res;\n    }\n}\n```\n\n# 方法二：不定长滑窗\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) { List<Integer> res = new ArrayList<>();\n        int[] cnt = new int[30];\n\n        for (char c : p.toCharArray()) {\n            cnt[c-'a']++;\n        }\n        int l=0;\n        for(int r=0;r<s.length();r++)\n        {\n            int c = s.charAt(r)-'a';\n            cnt[c]--;\n           while(cnt[c]<0) {  \n            cnt[s.charAt(l)-'a']++;\n            l++;\n           }\n            if(r-l+1==p.length())\n            {\n                res.add(l);\n            }\n\n        }\n        \n        return res;\n    }\n}\n\n```\n","tags":["算法,双指针"]},{"title":"openGl配置","url":"/2024/09/23/openGl配置/","content":"# 注意配置\n\n![OpenGL配置截图](image1.png)\n","tags":["openGl"]},{"title":"idea踩坑","url":"/2024/09/08/idea踩坑/","content":"# idae踩坑  \n\n![修改示例](image1.png)  \n***需要在这里将java设置与项目相同，否则无法打包***\n"},{"title":"2024-6-20随笔","url":"/2024/06/20/2024-6-20随笔/","content":"\n## 学习有感\n\n## 学习三角\n\n- 学习加深方式便是练习与交流想法\n\n![alt text](image1.png)\n"},{"title":"网站新增","url":"/2024/05/27/网站新增/","content":"\n新建主题中的评论机制\n"},{"title":"动画版小谢","url":"/2024/05/25/动画版小谢/","content":"\n# 通过chatgpt-4o生成\n\n![也许会一直喜欢](image2.png)\n\n---\n\n![也许会一直喜欢](image1.webp)\n"},{"title":"2024-5-15学习进度","url":"/2024/05/15/2024-5-15学习进度/","content":"\n- 已经学习至**js-dom**\n"},{"title":"2024-5-14小计","url":"/2024/05/14/2024-5-14小计/","content":"\n今天学习了java的reflect，可以通过forname获取对象，从而得到该类的所有信息，例如：类中的方法，属性，构造函数等。以及其对应的类型。还学写了代理，通过代理可以调用被代理对象的方法，并且可以在方法执行前后添加一些代码。分为静态与动态代理，静态代理需要提前写好代理类，而动态代理不需要提前写好代理类，但是需要提前写好接口。了解了日志和单元测试。\n"},{"title":"Java中reflect的学习","url":"/2024/05/13/Java中reflect的学习/","content":"\n```\npackage reflect;\n\nimport reflect.entity.Employee;\n\npublic class ClassSample {\n    public static void main(String[] args) {\n        try {\n            Class emplyeeClass = Class.forName(\"reflect.entity.Employee\");//返回具有指定名称的类对象\n            System.out.println(\"已被加载\");\n            Employee emp = (Employee) emplyeeClass.newInstance();//使用类对象生成对象\n            System.out.println(emp);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);//类名与类路径错误\n        } catch (InstantiationException e) {\n            throw new RuntimeException(e);//实例化异常，例如抽象类无法被实例化\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);//权限不足，作用域外\n             }\n        }\n    }\n\n\n```\n"},{"title":"端口与套接字","url":"/2024/05/12/端口与套接字/","content":"\n# 端口与套接字\n\n1.端口相当于为服务提供连接，套接字是为了将程序与端口连接。\n![alt text](image1.png) 2.端口号：0-65535，0-1023为系统端口，1024-49151为用户端口，49152-65535为保留端口。\n![alt text](image2.png)\n"},{"title":"博文测试","url":"/2024/05/12/你好/","content":"![alt text](image1.jpeg)\n"},{"title":"时间冉冉","url":"/2024/05/09/时间冉冉/"},{"title":"2024-3-21","url":"/2024/03/21/2024-3-21/","content":"![img](https://image.cai094.top/file/af7dbf6d3e58627caaee1.jpg \"谢楚灵\")"},{"title":"Git使用方法","url":"/2024/03/18/Git使用方法/","content":"- **1 工作流**   \n首先你可以提出更改（把它们添加到暂存区），使用如下命令：  \n ```  \n git add <filename>  //表示添加文件到缓存区\ngit add *或git add . //表示添加所有1文件\n ```  \n- **2**   \n这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：  \n``` git commit -m \"代码提交信息\"   ```  \n现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。  \n- **3 推送改动**  \n你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：  \n``` git push origin master ```  \n可以把 master 换成你想要推送的任何分支。  \n如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：  \n``` git remote add origin <server>  ```  \n如此你就能够将你的改动推送到所添加的服务器上去了。\n- **4 更新与合并**  \n要更新你的本地仓库至最新改动，执行：  \ngit pull\n以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。  \n要合并其他分支到你的当前分支（例如 master），执行：  \n```git merge <branch>```  \n在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。 这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：  \n```git add <filename> ```  \n在合并改动之前，你可以使用如下命令预览差异：  \n```git diff <source_branch> <target_branch>   ```\n\n- ### 分支  \n分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是\"默认的\"分支。在其他分支上进行开发，完成后再将它们合并到主分支上。  \n创建一个叫做\"feature_x\"的分支，并切换过去：  \n```git checkout -b feature_x ```   \n切换回主分支：   \n```git checkout master  ```  \n再把新建的分支删掉：  \n```git branch -d feature_x  ```  \n除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：  \n```git push origin <branch>  ```"},{"title":"2024-3-4-1229-日期问题.cpp","url":"/2024/03/04/2024-3-4-1229-日期问题-cpp/","content":"# 2024-3-4-1229-日期问题.cpp\n\n<details>\n<summary> 2024-3-4-1229-日期问题.cpp </summary>\n\n``` c++ \n\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nint days[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nbool check_vaild(int year,int month,int day){\n    if(month==0||month>12)return false;\n    if(month!=2){\n        if(day==0||day>days[month])return false;}\n\n    if(month==2)\n    {\n        int leap=year%4==0&&year%100||year%400==0;\n        if(day==0||day>28+leap)return false;\n    }\n    return true;\n}\nint main()\n{       int a,b,c;\n    scanf(\"%d/%d/%d\", &a,&b,&c);\n    for(int date=19600101;date<20591231;date++){\n        int year=date/10000,month=date%10000/100,day=date%100;\n        if(check_vaild(year,month,day))\n        {\n            if(year%100==a&&month==b&&day==c||//年月日表示\n            year%100==c&&month==a&&day==b||//月日年表示\n            year%100==c&&month==b&&day==a//日月年表示\n            )\n            printf(\"%d-%02d-%02d\\n\",year,month,day);//02表示不足2位补0\n        }\n    }\n\n        return 0;\n}\n\n```  \n</details>","tags":["算法"]},{"title":"2024-3-4-1219-移动距离.cpp","url":"/2024/03/04/2024-3-4-1219-移动距离-cpp/","content":"# 2024-3-4-1219-移动距离.cpp\n```\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint n,m,w;\nint main()\n{cin>>w>>m>>n;\nm--;\nn--;\nint x1=m/w,x2=n/w;\nint y1=m%w,y2=n%w;\nif(x1%2)y1=w-1-y1;\nif(x2%2)y2=w-1-y2;\n\n\n    int res=abs(x1-x2)+abs(y1-y2);\n    cout<<res;\n    return 0;\n}\n\n```","tags":["算法","距离"]},{"title":"2024-3-3-466-回文日期.cpp","url":"/2024/03/04/2024-3-3-466-回文日期-cpp/","content":"# 2024-3-3-466-回文日期.cpp\n```\n#include <iostream>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\nconst int N = 10010;\n\nint day1,day2,res,days[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n\nbool check(int date)\n{int year=date/10000;\nint mouth=date%10000/100;\nint day=date%100;\nif(mouth==0||mouth>12)return false;\nif(day==0||mouth!=2&&day>days[mouth]) return false;\nint leap=year%100&&year%4==0||year%400==0;//注意闰年判断条件\nif(mouth==2){\nif(day>28+leap) return false;\n}\nreturn true;\n}\nint main()\n{\n    cin>>day1>>day2;\n    int rea=0;\n    for(int i=1000;i<10000;i++)\n    {\n        int date=i,x=i;\n        for(int j=0;j<4;j++)\n            date=date*10+x%10,x/=10;\n        if(day1<=date&&day2>=date&&check(date))res++;\n    }\n    cout<<res;\n    return 0;\n}\n\n```","tags":["算法"]},{"title":"2024-3-3-1245- 特别数的和.cpp","url":"/2024/03/04/2024-3-3-1245-特别数的和-cpp/","content":"# 2024-3-3-1245- 特别数的和.cpp\n\n```  \n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include<cstdio>\nint n,res;\nusing namespace std;\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {int j=i;\n        while(j)\n        {\n            int cnt=j%10;\n            j=j/10;\n            if(cnt==2||cnt==0||cnt==1||cnt==9)\n            {res+=i;break;}\n        }\n    }\n    cout<<res;\n    return 0;\n}\n\n```","tags":["算法"]},{"title":"2024-3-3-1204- 错误票据.cpp","url":"/2024/03/03/2024-3-3-1204-错误票据-cpp/","content":"# 2024-3-3-1204- 错误票据.cpp\n```\n#include <iostream>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\nconst int N = 10010;\nint n,a[N];int res1,res2;\nint main()\n{\n    int cnt;\n    cin>>cnt;\n    string line;\n    getline(cin,line);//忽略第一行回车\n    while (cnt -- )\n    {\n        getline(cin,line);\n        stringstream ssin(line);\n        while(ssin>>a[n])n++;\n    }\n    sort(a,a+n);\n\n    for (int i = 1; i < n; i ++ )\n    {\n        if(a[i]==a[i-1])res2=a[i];\n        else if(a[i]>=a[i-1]+2) res1=a[i]-1;\n    }\n    cout<<res1<<\" \"<<res2;\n}\n\n```","tags":["算法"]},{"title":"2024-3-2-562-壁画.cpp","url":"/2024/03/03/2024-3-2-562-壁画-cpp/","content":"# 2024-3-2-562-壁画.cpp\n```\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include<cstdio>\nusing namespace std;\nconst int N = 1e7;\nint s[N],n;\nchar a[N];\nint T;\n\n\nint main()\n{\n    cin>>T;\n for(int x=1;x<=T;x++)\n    {   cin>>n;\n        cin>>a;\n        int ans=0;\n        for(int i=1;i<=n;i++) s[i]=a[i-1]+s[i-1]-'0';\n\n        int m=(n+1)/2;\n            for(int j=m;j<=n;j++)\n                ans=max(ans,s[j]-s[j-m]);\n        cout<<\"Case #\"<<x<<\": \"<<ans<<endl;\n    }\n\n    return 0;\n}\n\n```","tags":["算法"]},{"title":"2024-3-2-4262-空调.cpp","url":"/2024/03/03/2024-3-2-4262-空调-cpp/","content":"# 2024-3-2-4262-空调.cpp\n```#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include<cstdio>\nconst int N = 1e5+10;\nint a[N],b[N];\nint n;\n\nusing namespace std;\nvoid batch_add(int l,int r,int c){//创建差分数组\n    b[l]+=c,b[r+1]-=c;\n    cout<<b[l]<<\" \"<<b[r+1]<<endl;\n}\n\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++){\n        int t;cin>>t;\n        a[i]-=t;\n    }\n    for(int i=1;i<=n;i++)batch_add(i,i,a[i]);\n    int s=0,t=0;\n    for(int i=1;i<=n;i++){\n        if(b[i]>0)s+=b[i];\n        else if(b[i]<0)t-=b[i];\n    }\n\ncout<<max(s,t);\n\n    return 0;\n}\n\n\n\n```","tags":["算法"]},{"title":"2024-3-2-1236-递增三元组.cpp","url":"/2024/03/03/2024-3-2-1236-递增三元组-cpp/","content":"# 2024-3-2-1236-递增三元组.cpp\n\n```\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include<cstdio>\nusing namespace std;\nconst int N = 100010;\nint cnt[N],as[N],cs[N];//as[i]表示在a[]中有多少数小于b[i]\nint a[N],b[N],c[N],s[N],n;//cs[i]表示在c[]中有多少数大于b[i]\n\n\nint main()\n{   cin>>n;\n    for (int i = 0; i < n; i ++ ) scanf(\"%d\", &a[i]),a[i]++;\n    for (int i = 0; i < n; i ++ ) scanf(\"%d\", &b[i]),b[i]++;\n    for (int i = 0; i < n; i ++ ) scanf(\"%d\", &c[i]),c[i]++;\n\n    for(int i=0;i<n;i++)cnt[a[i]]++;\n    for (int i = 1; i <N; i ++ )s[i]=s[i-1]+cnt[i];\n    for (int i = 0; i < n; i ++ ) as[i]=s[b[i]-1];\n\n    //求cs[]\n    memset(cnt, 0, sizeof cnt);memset(s,0,sizeof s);\n    for(int i=0;i<n;i++)cnt[c[i]]++;\n    for(int i=1;i<N;i++)s[i]=s[i-1]+cnt[i];\n    for(int i=0;i<n;i++)cs[i]=s[N-1]-s[b[i]];\n\n    long long res=0;\n    for(int i=0;i<n;i++) res+=(long long)as[i]*cs[i];/*错误实例res+=\n    (long long)(as[i]*cs[i]);不需要加括号*/\n    cout<<res<<endl;\n    return 0;\n\n}\n\n\n```","tags":["算法"]},{"title":"2024-3-2-1214-波动数列.cpp","url":"/2024/03/03/2024-3-2-1214-波动数列-cpp/","content":"# 2024-3-2-1214-波动数列.cpp\n```\n#include <iostream>\n#include <cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=1010,MOD=100000007;\nint f[N][N];\nint n,s,a,b;\nint get_mod(int a,int b)\n{\n    return (a%b+b)%b;\n}\nint main()\n{ scanf(\"%d%d%d%d\", &n, &s, &a, &b);\nf[0][0]=1;\nfor(int i=1;i<n;i++)\n    for(int j=0;j<n;j++)\n    {//注意，f[i][j] 代表第i位，取i个a或-b，模n为j的个数；\nf[i][j]=(f[i-1][get_mod(j-a*(n-i),n)]+f[i-1][get_mod(j+b*(n-i),n)])%MOD;//题解https://www.cnblogs.com/onlyblues/p/15907623.html\n\n    }\n     cout<<f[n-1][get_mod(s,n)]<<endl;\n    return 0;\n}\n\n```","tags":["算法"]},{"title":"2024-3-2-1210-连号区间数.cpp","url":"/2024/03/03/2024-3-2-1210-连号区间数-cpp/","content":"# 2024-3-2-1210-连号区间数.cpp\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=10010;\nint a[N];\nint n,res;\nint main()\n{\ncin>>n;\nfor (int i = 0; i < n; ++i)\n{\n    scanf(\"%d\",&a[i]);\n}\nfor (int i = 0; i < n; ++i)\n{\n    int manx=-N,minx=N;\n    for (int j = i; j <n ; ++j)\n    {\n        manx=max(manx,a[j]);\n        minx=min(minx,a[j]);\n        if(manx-minx==j-i) res++;\n}\n    }\ncout<<res;\n\n\n    return 0;\n}\n\n```","tags":["算法"]},{"title":"2024-3-1-895-最长上升子序列.cpp","url":"/2024/03/03/2024-3-1-895-最长上升子序列-cpp/","content":"# 2024-3-1-895-最长上升子序列.cpp\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=5005;\nint a[N],f[N];\nint n;\nint main()\n{\n    cin>>n;\nfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    int res=0;\nfor(int i=1;i<=n;i++)\n{   f[i]=1;\n    for(int j=1;j<i;j++)\n    {\n        if(a[i]>a[j])\n            f[i]=max(f[i],f[j]+1);\n        res=max(res,f[i]);\n    }\n}\ncout<<res;\n    return 0;\n}\n\n\n```","tags":["算法"]},{"title":"2024-3-1-1212- 地宫取宝.cpp","url":"/2024/03/03/2024-3-1-1212-地宫取宝-cpp/","content":"# 2024-3-1-1212- 地宫取宝.cpp\n```\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\nconst int N = 55;\nint MOD=1000000007;\nint n,m,k;\nint w[N][N];\nint f[N][N][13][14];\n\n\n\nint main()\n{\n\n    cin>>n>>m>>k;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        {\n            cin>>w[i][j];\n            w[i][j]++;\n        }\n    f[1][1][1][w[1][1]]=1;\n    f[1][1][0][0]=1;\n    for(int i = 1; i <= n; i ++ )\n        for(int j= 1; j <= m; j ++ )\n        {if(i==1||j==1) continue;\n        for(int u = 0;u<= k; u ++ )\n        for(int v = 0; v <= 13; v ++ )\n        {\n            int &val=f[i][j][u][v];\n            val=(val+f[i-1][j][u][v])%MOD;\n            val=(val+f[i][j-1][u][v])%MOD;\n            if(u>0&&v==w[i][j])\n            {\n                for(int c=0;c<v;c++)\n                {\n                    val=(val+f[i-1][j][u-1][c])%MOD;\n                    val=(val+f[i][j-1][u-1][c]%MOD);\n                }\n            }\n        }\n        }\n\n        int res=0;\n        for (int i = 0; i < 13; i ++ ) res=(res+f[n][m][k][i])%MOD;\n        cout<<res;\n\n\n\n    return 0;\n}\n\n```","tags":["算法"]},{"title":"2024-3-1-1015-摘花生.cpp","url":"/2024/03/03/2024-3-1-1015-摘花生-cpp/","content":"# 2024-3-1-1015-摘花生.cpp\n```\n\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N =105;\nint res;\nint T,R,C,M[N][N],F[N][N];\nint main()\n{\ncin>>T;\nwhile(T--)\n{\nscanf(\"%d%d\",&R,&C);\nfor(int i=1;i<=R;i++)\n    for(int j=1;j<=C;j++)\n        scanf(\"%d\",&M[i][j]);\nfor(int i=1;i<=R;i++)\n    for(int j=1;j<=C;j++)\n       {F[i][j]=M[i][j];\n        F[i][j]+=max(F[i-1][j],F[i][j-1]);\n}cout<<F[R][C]<<endl;\n\n}\n    return 0;\n}\n\n```","tags":["算法"]},{"title":"2024-2-29-02-01背包问题.cpp","url":"/2024/02/29/2024-2-29-02-01背包问题-cpp/","content":"# 2024-2-29-02-01背包问题.cpp\n```#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=1005;\n\nint n,m;\nint v[N],w[N];\nint f[N][N];\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) scanf(\"%d%d\",&v[i],&w[i]);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        {f[i][j]=f[i-1][j];\n        if(j>=v[i]) f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]);\n\n\n        }\n\nprintf(\"%d\\n\",f[n][m]);\nreturn 0;\n}\n```","tags":["算法"]},{"title":"2024-2-29-503-借教室.cpp","url":"/2024/02/29/2024-2-29-503-借教室-cpp/","content":"# 2024-2-29-503-借教室.cpp\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=1e6+10;\nstruct st{\nint d,s,t;\n};\nst s[N];\nint n,m;\nint r[N];\nlong long diff[N];\nbool check(int m)\n{memset(  diff, 0, sizeof diff);\n    for(int i=1;i<=m;i++)\n       { diff[s[i].s]+=s[i].d;\n        diff[s[i].t+1]-=s[i].d;}\n\n    for(int i=1;i<=n;i++)\n    {diff[i]+=diff[i-1];\n        if(r[i]<diff[i])\n        return false;}\n\nreturn true;\n\n}\n\nint main()\n{\n    cin>>n>>m;\nfor(int i=1;i<=n;i++)\n    scanf(\"%d\",&r[i]);\nfor(int i=1;i<=m;i++)\n    scanf(\"%d%d%d\",&s[i].d,&s[i].s,&s[i].t);\n\nint l=1,r=m;\nwhile(r>l)\n{int mid=(r+l+1)>>1;\n    if(check(mid))\n        l=mid;\n    else r=mid-1;\n}\n\nif(l==m)\n    cout<<0;\nelse cout<<-1<<endl<<r+1;\n\nreturn 0;\n}\n\n```","tags":["算法"]},{"title":"2024-2-28-1205-买不到的数目.cpp","url":"/2024/02/29/2024-2-28-1205-买不到的数目-cpp/","content":"# 2024-2-28-1205-买不到的数目.cpp\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint main()\n{\nint n,m;\ncin>>n>>m;\ncout<<(n-1)*(m-1)-1;\n    return 0;\n\n}\n\n```","tags":["算法"]},{"title":"2024-2-28-1216- 饮料换购.cpp","url":"/2024/02/29/2024-2-28-1216-饮料换购-cpp/","content":"# 2024-2-28-1216- 饮料换购.cpp\n```\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint res;\nint main()\n{\n    int n;\n    cin>>n;\n    int res=n;\n    while(n>=3)\n    {\n      res+=n/3;  \n    n=n/3+n%3;\n    }\n    cout<<res;\n    return 0;\n    \n}\n\n```","tags":["算法"]},{"title":"实现向上取整","url":"/2024/02/29/实现向上取整/","content":" # 公式  \n *** a/b,向上取整位（a+b-1）/b ***"},{"title":"2024-2-28-1230-K倍区间.cpp","url":"/2024/02/28/2024-2-28-1230-K倍区间-cpp/","content":"# 2024-2-28-1230-K倍区间.cpp\n```\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include<cstdio>\nconst int N = 1e5+10;\nint n,k;\nlong long s[N],cnt[N];//防止出现数据过大\n\n\nusing namespace std;\nint main()\n{scanf(\"%d%d\",&n,&k);\n    for (int i = 1; i <= n; i ++ )\n    {int m;\n        scanf(\"%d\", &m);\n        s[i]=s[i-1]+m;\n    }\n\nlong long res=0;//防止出现数据过大\ncnt[0] = 1;\nfor(int r=1;r<=n;r++)\n{int mod=s[r]%k;\n    res+=cnt[mod];\n    cnt[mod]++;\n}\ncout<<res;\n\n    return 0;\n}\n\n```","tags":["算法"]},{"title":"2024-2-28-99-激光炸弹.cpp","url":"/2024/02/28/2024-2-28-99-激光炸弹-cpp/","content":"# 2024-2-28-99-激光炸弹.cpp\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=5010;\n\nint n,m; int cnt,r; int s[N][N];\n\nint main() { cin>>cnt>>r; r=min(5001,r); n=m=r;\n\nwhile(cnt--)\n{\n    int x,y,w;\n    cin>>x>>y>>w;\n    x++,y++;\n    n=max(n,x),m=max(m,y);\n    s[x][y]+=w;\n}\n\nfor(int i=1;i<=n;i++)\n    for(int j=1;j<=m;j++)\n        s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];//二维前缀和\n\nint res=0;\nfor(int i=r;i<=n;i++)\n    for(int j=r;j<=m;j++)\n        res=max(res,s[i][j]-s[i-r][j]-s[i][j-r]+s[i-r][j-r]); //计算滑动窗口中的最大值\n\ncout<<res<<endl;\nreturn 0;\n}\n\n```","tags":["算法"]},{"title":"2024-2-27-796-子矩阵的和.cpp","url":"/2024/02/27/2024-2-27-796-子矩阵的和-cpp/","content":"# 2024-2-27-796-子矩阵的和.cpp\n```\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int N=1005;\nint a[N][N],s[N][N],ans[N];\nint n,m,q,x1,x2,y1,y2,z;\nint main()\n{\nscanf(\"%d%d%d\",&n,&m,&q);\nfor(int i=1;i<=n;i++)\n    for(int j=1;j<=m;j++)\n        {scanf(\"%d\",&a[i][j]);\n    s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];\n        }\nwhile(q--)\n{\nscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\nprintf(\"%d\",s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1]);\n}\n    return 0;\n\n}\n\n```","tags":["算法"]},{"title":"2024-2-27-795-前缀和.cpp","url":"/2024/02/27/2024-2-27-795-前缀和-cpp/","content":"# 2024-2-27-795-前缀和.cpp\n```\n#include<cstring>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int N=100010;\nint n,m;\nint a[N],s[N];\nint main()\n{\n\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        s[i]=s[i-1]+a[i];\n    }\n    while(m--)\n    {   int r,l;\n        scanf(\"%d%d\",&l,&r);\n        printf(\"%d\\n\",s[r]-s[l-1]);\n    }\n    return 0;\n}\n\n```","tags":["算法"]},{"title":"2024-2-27-1227-分巧克力.cpp","url":"/2024/02/27/2024-2-27-1227-分巧克力-cpp/","content":"# 2024-2-27-1227-分巧克力.cpp\n```\n\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int N=100010;\n\nint n,k;\nint h[N],w[N];\nbool check(int mid)\n{\n    int res=0;\n    for(int i=0;i<n;i++)\n    {\n        res+=(h[i]/mid)*(w[i]/mid);if(res>=k) return true;\n    }\n\n    return false;\n}\n\nint main(){\n    cin>>n>>k;\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%d%d\",&h[i],&w[i]);\n    }\n    int l=1,r=1e5;\n    while(l<r)\n    {\n        int mid=(l+r+1)>>1;\n        if(check(mid)) l=mid;\n        else r=mid-1;\n    }\n    printf(\"%d\\n\",l);\n    return 0;\n}\n\n```","tags":["算法"]},{"title":"2024-2-27-1221-四平方和-哈希表版本.cpp","url":"/2024/02/27/2024-2-27-1221-四平方和-哈希表版本-cpp/","content":"# 2024-2-27-1221-四平方和-哈希表版本.cpp\n\n```\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<map>\n#include <unordered_map>\nusing namespace std;\n#define x first\n#define y second\ntypedef pair<int,int> PII;\nconst int N=2500010;\nstruct sum{\n    int s,c,d;\n    bool operator< (const sum &t)const\n    {\n        if(s!=t.s)return s<t.s;\n        if(s!=t.c)return c<t.c;\n        return d<t.s;\n    }\n}sum[N];\nint n,m;\nunordered_map<int, PII> S;\nint main()    //二分版本\n{\ncin>>n;\nfor(int c=0;c*c<=n;c++)\n    for(int d=c;c*c+d*d<=n;d++)\n        {   int t=c*c+d*d;\n            if(S.count(t)==0)S[t]={c,d};\n                }\n\nfor(int a=0;a*a<=n;a++)\n    for(int b=a;b*b+a*a<=n;b++)\n        {\n            int t=n-a*a-b*b;\n            if(S.count(t))\n            {\n                printf(\"%d %d %d %d\\n\",a,b,S[t].x,S[t].y );\n                return 0;\n            }\n        }\n     return 0;\n}\n\n```","tags":["算法"]},{"title":"2024-2-27-1221-四平方和-二分版本.cpp","url":"/2024/02/27/2024-2-27-1221-四平方和-二分版本-cpp/","content":"# 2024-2-27-1221-四平方和-二分版本.cpp\n\n\n\n```\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\nusing namespace std;\nconst int N=2500010;\nstruct sum{\n    int s,c,d;\n    bool operator< (const sum &t)const\n    {\n        if(s!=t.s)return s<t.s;\n        if(s!=t.c)return c<t.c;\n        return d<t.s;\n    }\n}sum[N];\nint n,m;\nint q[N];\nint main()    //二分版本\n{\ncin>>n;\nfor(int c=0;c*c<=n;c++)\n    for(int d=c;c*c+d*d<=n;d++)\n        sum[m++]={c*c+d*d,c,d};\nsort(sum,sum+m);\n    for(int a=0;a*a<=n;a++)\n        for(int b=a;b*b+a*a<=n;b++)\n        {\n            int t=n-a*a-b*b;\n            int l=0,r=m;\n            while(r>l)\n            {int mid=(r+l)>>1;\n                if(sum[mid].s>=t)\n                    r=mid;\n                else l=mid+1;\n\n            }\n            if(sum[l].s==t)\n            {\n                printf(\"%d %d %d %d\\n\",a,b,sum[l].c,sum[l].d);\n                return 0;\n            }\n        }\n     return 0;\n}\n\n\n\n```","tags":["算法"]},{"title":"2024-2-27-730飞行员兄弟.cpp","url":"/2024/02/27/2024-2-27-730飞行员兄弟-cpp/","content":"# 2024-2-27-730飞行员兄弟.cpp\n```\n#include <iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=100010;\nint n;\nint h[N];\n\nbool check(int e)\n{\n    for(int i=1;i<=n;i++)\n    {\n        e=e*2-h[i];\n        if(e>=1e5)\n        return true;\n        if(e<0) return 0;\n    }\n    return true;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&h[i]);\n    int l=0,r=1e5;\n    while(r>l){\n     int mid=l+r>>1;\n     if(check(mid))\n     r=mid;\n     else l=mid+1;\n    }\n    printf(\"%d\\n\",l);\n    return 0;\n}\n\n```","tags":["算法"]},{"title":"英语有感","url":"/2023/12/21/英语有感/","content":"***1.胆识  \n2.投资自己的智慧，向成功者借智慧   \n3.学习英语，必须是按照“听、说、读、写、译”的顺序，就像我们小孩子在会讲话前，肯定是先能听清爸爸妈妈的讲话，才能进行模仿，然后才能讲话。***"},{"title":"线性表cpp","url":"/2023/12/14/线性表cpp-1/","content":"\n```cpp\n/*********************************************************************\n    程序名:\n    版权:\n    作者: 蔡6\n    日期: 2023-12-14 15:15\n    说明: cai6.love\n*********************************************************************/\n#include <iostream>\nusing namespace std;\n#define ok 1\n#define error 0\n#define true 1\n#define false 0\n#define maxsize 20\ntypedef int elemtype;\n\n\ntypedef struct {\n\telemtype date[maxsize];\n\tint length;\n} SqList;\n\ntypedef int Status;//Status为函数返回状态\n\n/* 初始化顺序线性表 */\nStatus InitList(SqList *L) {\n\tL->length = 0;\n\treturn ok;\n}\n\nStatus visit(elemtype c) { //查看数据\n\tcout << c;\n\treturn ok;\n}\n\nStatus InstEmpty(SqList L) {\n\tif (L.length == 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n\n}\n\nStatus ClearList(SqList *L) { //需要对其进行修改则使用指针，或者引用&\n\tL->length = 0;\n\treturn ok;\n}\n\nStatus GetElen(SqList *L, int i, elemtype *e) { //获取第i位元素，并将其赋值给e\n\tif (L->length == 0 || i < 1 || i > L->length)\n\t\treturn error;\n\t*e = L->date[i - 1];\n\treturn ok;\n}\n\nStatus  ListInsert(SqList *L, int i, elemtype e) {\n\t//对线性表的第i位进行插入e\n\tif (L->length == maxsize )\n\t\treturn error;\n\tif ( i < 1 || i > L->length + 1)\n\t\treturn error;\n\tif (i <= L->length) {\n\t\tfor (int k = L->length - 1; k >= i - 1; k--)\n\t\t\tL->date[k + 1] = L->date[k];\n\t}\n\tL->date[i - 1] = e;\n\tL->length++;\n\n\n\treturn ok;\n}\n\n\nStatus ListDelete(SqList *L, int i) {\n\tif ( i < 1 || i > L->length + 1)\n\t\treturn error;\n\tif (i <= L->length) {\n\t\tfor (int k = L->length - 2; k >= i - 1; k--)\n\t\t\tL->date[k] = L->date[k + 1];\n\t}\n\tL->length--;\n\n\n\treturn ok;\n\n}\n\n/* 初始条件：顺序线性表L已存在。操作结果：返回L中数据元素个数 */\nint ListLength(SqList L) {\n\treturn L.length;\n}\n\nStatus ListTraverse(SqList L) { //依次输出全部数据\n\tfor (int i = 0; i < L.length; i++) {\n\t\tcout << L.date[i] << endl;\n\t}\n\treturn ok;\n}\n\nint main() {\n\tStatus i;\n\tSqList L;\n\ti = InitList(&L);\n\tprintf(\"初始化L后：L.length=%d\\n\", L.length);\n\tint a = 2;\n\ti = ListInsert(&L, 1, a);\n\ti = ListInsert(&L, 1, 5);\n\ti = ListTraverse(L);\n\ti = ListDelete(&L, 2);\n\ti = ListTraverse(L);\n\treturn 0;\n}\n\n```\n\n"},{"title":"今日搭建进度","url":"/2023/12/05/今日搭建进度/","content":"完成netlify拉取，利用dns进行加速，已将github库设置为private"},{"title":"在hexo中插入音乐","url":"/2023/12/04/在hexo中插入音乐/","content":"[链接](https://easyhexo.com/3-Plugins-use-and-config/3-1-hexo-tag-aplayer/)","categories":["教程"]},{"title":"12/4","url":"/2023/12/04/12-4/","content":"## 完成hexo基础搭建\n  ***1.全局音乐播放器搭建完毕  \n  2.living-2d搭建完毕  \n  3.本地端后台搭建完毕***"},{"title":"算法竞赛入门经典3-2","url":"/2023/12/03/算法竞赛入门经典3-2/","content":"### 算法竞赛入门经典3-2\n```\n2023-12-02 10:35 \n\n/***\n *                    _ooOoo_\n *                   o8888888o\n *                   88\" . \"88\n *                   (| -_- |)\n *                    O\\ = /O\n *                ____/`---'\\____\n *              .   ' \\\\| |// `.\n *               / \\\\||| : |||// \\\n *             / _||||| -:- |||||- \\\n *               | | \\\\\\ - /// | |\n *             | \\_| ''\\---/'' | |\n *              \\ .-\\__ `-` ___/-. /\n *           ___`. .' /--.--\\ `. . __\n *        .\"\" '< `.___\\_<|>_/___.' >'\"\".\n *       | | : `- \\`.;`\\ _ /`;.`/ - ` : | |\n *         \\ \\ `-. \\_ __\\ /__ _/ .-` / /\n * ======`-.____`-.___\\_____/___.-`____.-'======\n *                    `=---='\n *\n * .............................................\n *          佛祖保佑             永无BUG\n */\n\n\n/***\n * http://www.flvcd.com/\n *  .--,       .--,\n * ( (  \\.---./  ) )\n *  '.__/o   o\\__.'\n *     {=  ^  =}\n *      >  -  <\n *     /       \\\n *    //       \\\\\n *   //|   .   |\\\\\n *   \"'\\       /'\"_.-~^`'-.\n *      \\  _  /--'         `\n *    ___)( )(___\n *   (((__) (__)))    高山仰止,景行行止.虽不能至,心向往之。\n */\n\n\n#include <iostream>\n#include <string.h>\nusing namespace std;\n\nint a[1005], n, k;\n// If this comment is removed the program will blow up\n// 如果删了此处注释程序就炸了\n\nint main() {\n\tmemset(a, 0, sizeof(a)); //将a置0,需包含<string.h>\n\tcin >> n >> k;\n\tfor (int i = 1; i <= k; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (j % i == 0) {\n\t\t\t\ta[j] = !a[j];\n\t\t\t}\n\t\t}\n\t}\n\tint first = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (a[i]) {\n\t\t\tcout << \" \" << i;\n\t\t}\n\tcout << endl;\n\n\treturn 0;\n}\n\n```\n"},{"title":"Hexo备份事项","url":"/2023/12/03/Hexo备份事项/","content":"\n### 由于每次更新后都要输入大量命令行十分麻烦，遂创建一键部署脚本方便备份部署\n\n在博客根目录下创建deploy.sh文件，写入\n\n\n```\necho \"Start\"\ngit add .\ngit commit -m backup\ngit push\nhexo g\nhexo d\necho \"Finish\"\necho 按任意键继续\nread -n 1\n```\n\n保存后，在博客根目录双击执行或用命令./deploy.sh 即可实现博客的一键备份并部署\n\n### 恢复博客\n基础环境搭建\nHexo博客基础环境已经搭好：比如安装npm、git、nodejs、hexo安装…\n\n克隆项目到本地\nCtrl+Alt+T打开终端，输入\n\n\n```\ngit clone git@gitee.com:stringwind/blog_backup.git\n```\n\n\ngit clone 自己的仓库地址\n\n恢复博客\n在clone来的文件夹里执行\n\n\n```\nnpm install hexo-cli\nnpm install\nnpm install hexo-deployer-git\n```\n==注意由于主题未备份，需要进入站源文件修改主题为默认主题才可恢复==\n这样博客源文件就成功移植了，再用hexo clean、hexo g、hexo d即可部署完成"},{"title":"12/3随笔","url":"/2023/12/03/12-3随笔/","content":"- ***1.过去的我已经死亡，而今的我正在奔赴死亡***\n- 2.起心动念，每一刻都站在死亡之间循环重生"},{"title":"My lover","url":"/2023/12/03/My-lover/","content":"# my lover\n![xcl](https://cai6.xyz/file/af7dbf6d3e58627caaee1.jpg)\n"}]